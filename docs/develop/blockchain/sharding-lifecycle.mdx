# Infinity Sharding Paradigm


## Understanding Split Merge in TON Blockchain

The TON (Telegram Open Network) Blockchain introduces innovative concepts for blockchain scalability and efficiency. One such concept is the Split Merge functionality, integral to its blockchain architecture. This short article explores the key aspects of Split Merge in the TON Blockchain, focusing on its role within the Infinite Sharding Paradigm (ISP).

#### Infinite Sharding Paradigm (ISP) and its Application

ISP underpins the TON Blockchain's design, treating each account as part of its separate "accountchain." These accountchains are then aggregated into shardchain blocks for efficiency. The state of a shardchain comprises the states of all its accountchains. Thus, a shardchain block essentially is a collection of virtual blocks of accounts assigned to it.

- **ShardState**: Approximated as Hashmap(n, AccountState), where n is the bit length of the account_id.
- **ShardBlock**: Approximated as Hashmap(n, AccountBlock).

Each shardchain, or more precisely, each shardchain block, is identified by a combination of `workchain_id` and a binary prefix `s` of the account_id.

## Algorithm for deciding whether to split or merge

### 1. Assessment of the current state of the block

Before deciding whether to split or merge, it is necessary to assess the current state of the block. This includes an assessment of the block size, gas consumption and logical block time difference (lt_delta).

### 2. Block classification

Using the estimation results, we classify the block into three parameters and their limits: size, gas, and lt_delta.

There are three main classification classes for different block parameters and their limits:
- underload (0) - is a state where a shard understands that there is no load, and is inclined to merge if the neighbouring shard wishes to do so.
- soft limit (2) - when this limit is reached, internal messages are no longer processed.
- hard limit (4) - that's the absolute maximum size.

Block limits are loaded from the contract config - [23](/develop/howto/blockchain-configs#param-22-and-23).

At the moment, the classification of blocks is as follows:

#### Classification of Block size
- 0 - if block size < 131,072 bytes
- 2 - if 131,072 ≤ block size ≤ 524,288 bytes
- 4 - if block size = 524,288 bytes

#### Classification of Block gas
- 0 - if block gas < 2000000 gas
- 2 - if 2000000 ≤ block gas ≤ 10000000 gas
- 4 - if block gas = 20000000 gas

#### Classification of Block lt_delta
- 0 - if block lt_delta < 1000 lt_delta
- 2 - if 5000 ≤ block lt_delta ≤ 10000 lt_delta
- 4 - if block lt_delta = 10000 lt_delta

#### Final block classification:

Classification of block limit =  max(`Classification of Block size`, `Classification of Block gas`, `Classification of Block lt_delta`)

For example: if classification of Block size - 2, classification of Block gas - 2, classification of Block lt_delta - 4, then the final block classification is `hard(4)`.

### 3. Determination of overload or underload condition

After classifying the block, we check its overload or underload condition.

- If the block class by limits ≤ `underload(0)` and message queue ≤ `MERGE_MAX_QUEUE_SIZE = 2047`, set the status to `underloaded`.
- If the block class by limits ≥ `soft(2)` и message queue ≤ `SPLIT_MAX_QUEUE_SIZE = 100000`, set the status to `overloaded`.

### 4. Deciding whether to split or merge

Using the history of overloading and underloading, decide whether a split or merge is needed.

- If the overload history is `overload` and the message queue size is between `FORCE_SPLIT_QUEUE_SIZE = 4096` and `SPLIT_MAX_QUEUE_SIZE = 100000`, the `want_split` status is set.
- If the overload condition is `underloaded` and the message queue size ≤ `MERGE_MAX_QUEUE_SIZE = 2047`, the `want_merge` status is set.

### 5. Checking the manual settings of the collator

- If `want_split` is set in the collator settings, a split will be made.
- If `want_merge` is set in the collator settings, a merge will be made.

### 6. Final decision

The final decision to split or merge is based on `want_split` and `want_merge` values.

## Messages and Instant Hypercube Routing (Instant Hypercube Routing)

In the infinite sharding paradigm, each account (or smart-contract) is treated as if it were itself in a separate shardchain.
Interaction between accounts occurs solely through the sending of messages, which is part of the actor model where accounts act as actors. An efficient messaging system between shardchains is critical to the operation of the TON blockchain. 
A feature of TON is Instant Hypercube Routing, which enables fast delivery and processing of messages between shardchains, ensuring that messages created in a block of one shardchain are processed in the next block of the target shardchain, regardless of their number in the system.

## Sharding Example

![](/img/docs/blockchain-fundamentals/shardchains.jpg)

In the provided graphic scheme:

- Shards of a workchain are divided by time and denoted in dashed line.
- Blocks 222, 223, and 224 relate to the masterchain block with seqno=102. Here, 222 is in one shard, while 223 and 224 are in another.
- If a split or merge event happens, the affected shards pause until the next masterchain block.

In summary, Split Merge in TON Blockchain is a complex yet efficient mechanism that enhances scalability and interaction within the blockchain network. It exemplifies TON's approach to resolving common blockchain challenges, emphasizing efficiency and global consistency.


## Sharding Details

#### Split and Non-Split Parts of Shardchain

A shardchain block and state are divided into two parts:

1. **Split Part**: Complies with the ISP form, containing account-specific data.
2. **Non-Split Part**: Involves data pertaining to the block's interaction with other blocks and the outside world.

#### Interaction with Other Blocks

The non-split parts are crucial for ensuring global consistency, reduced to internal and external local consistency conditions. They are significant for:

- Message forwarding between shardchains.
- Transactions involving multiple shardchains.
- Delivery guarantees and validation of a block's initial state against its predecessor.

#### Inbound and Outbound Messages

Key components of the non-split part of a shardchain block include:

- **InMsgDescr**: Descriptions of all messages imported into the block (i.e., either processed by the transaction included in the block or forwarded to the output queue, in the case of a transient message traveling along a path dictated by `Hypercube Routing`).
- **OutMsgDescr**: Descriptions of all messages exported or generated by the block (i.e. either messages generated by a transaction included in the block, or transit messages with a destination not belonging to the current shardchain, forwarded from `InMsgDescr`).

#### Block Header and Validator Signatures

The block header, another non-split component, contains essential information like `workchain_id`, binary prefix of `account_ids`, block sequence number (defined as the smallest non-negative integer greater than the sequence numbers of its predecessors), logical time, and unixtime generation. It also contains a hash of the immediate predecessor of the block (or its two immediate predecessors in the case of a preceding
shardchain merge event), hashes of its initial and final states (i.e., the states of the shardchain immediately before and immediately after the current block is processed), and a hash of the most recent masterchain block known at the time the shardchain block was generated. Validator signatures are appended to the unsigned block, forming the signed block.

#### Outbound Message Queue

`OutMsgQueue` in the shardchain state is a critical non-split part. It contains undelivered messages included in `OutMsgDescr`, either by the last shardchain block leading to this state or by one of its predecessors. 
Initially, each outgoing message is included in the `OutMsgQueue` and stored there, until they are processed or delivered to their destination.

#### Shard Split and Merge Mechanics

In the context of dynamic sharding, shard configurations may change due to split and merge events. These events are synchronized with the masterchain block. For instance, if a split or merge occurs, the affected shards wait for the next masterchain block before proceeding.


## See Also

* [Block Layout](/develop/data-formats/block-layout)
* [Whitepapers](/learn/docs)